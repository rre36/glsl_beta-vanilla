separateAo=true

variable.float.upvecNorm    = 1.0 / sqrt((upPosition.x*upPosition.x) + (upPosition.y*upPosition.y) + (upPosition.z*upPosition.z))
uniform.vec3.upvecView      = vec3(upPosition.x*upvecNorm, upPosition.y*upvecNorm, upPosition.z*upvecNorm)
uniform.vec3.upvec          = vec3(0.0, 1.0, 0.0)

variable.float.sunvecNorm   = 1.0 / sqrt((sunPosition.x * sunPosition.x) + (sunPosition.y * sunPosition.y) + (sunPosition.z * sunPosition.z))
variable.float.svecX        = sunPosition.x * sunvecNorm
variable.float.svecY        = sunPosition.y * sunvecNorm
variable.float.svecZ        = sunPosition.z * sunvecNorm
uniform.vec3.sunvecView     = vec3(svecX, svecY, svecZ)
variable.float.sunvecX      = gbufferModelViewInverse.0.0 * sunPosition.x + gbufferModelViewInverse.1.0 * sunPosition.y + gbufferModelViewInverse.2.0 * sunPosition.z
variable.float.sunvecY      = gbufferModelViewInverse.0.1 * sunPosition.x + gbufferModelViewInverse.1.1 * sunPosition.y + gbufferModelViewInverse.2.1 * sunPosition.z
variable.float.sunvecZ      = gbufferModelViewInverse.0.2 * sunPosition.x + gbufferModelViewInverse.1.2 * sunPosition.y + gbufferModelViewInverse.2.2 * sunPosition.z
uniform.vec3.sunvec         = vec3(sunvecX * sunvecNorm, sunvecY * sunvecNorm, sunvecZ * sunvecNorm)

variable.float.moonvecNorm  = 1.0 / sqrt((moonPosition.x * moonPosition.x) + (moonPosition.y * moonPosition.y) + (moonPosition.z * moonPosition.z))
variable.float.mvecX        = moonPosition.x * moonvecNorm
variable.float.mvecY        = moonPosition.y * moonvecNorm
variable.float.mvecZ        = moonPosition.z * moonvecNorm
uniform.vec3.moonvecView    = vec3(mvecX, mvecY, mvecZ)
variable.float.moonvecX     = gbufferModelViewInverse.0.0 * moonPosition.x + gbufferModelViewInverse.1.0 * moonPosition.y + gbufferModelViewInverse.2.0 * moonPosition.z
variable.float.moonvecY     = gbufferModelViewInverse.0.1 * moonPosition.x + gbufferModelViewInverse.1.1 * moonPosition.y + gbufferModelViewInverse.2.1 * moonPosition.z
variable.float.moonvecZ     = gbufferModelViewInverse.0.2 * moonPosition.x + gbufferModelViewInverse.1.2 * moonPosition.y + gbufferModelViewInverse.2.2 * moonPosition.z
uniform.vec3.moonvec        = vec3(moonvecX * moonvecNorm, moonvecY * moonvecNorm, moonvecZ * moonvecNorm)

variable.float.lightvecNorm = 1.0 / sqrt((shadowLightPosition.x * shadowLightPosition.x) + (shadowLightPosition.y * shadowLightPosition.y) + (shadowLightPosition.z * shadowLightPosition.z))
uniform.vec3.lightvecView   = vec3(shadowLightPosition.x * lightvecNorm, shadowLightPosition.y * lightvecNorm, shadowLightPosition.z * lightvecNorm)
variable.float.lightvecX    = gbufferModelViewInverse.0.0 * shadowLightPosition.x + gbufferModelViewInverse.1.0 * shadowLightPosition.y + gbufferModelViewInverse.2.0 * shadowLightPosition.z
variable.float.lightvecY    = gbufferModelViewInverse.0.1 * shadowLightPosition.x + gbufferModelViewInverse.1.1 * shadowLightPosition.y + gbufferModelViewInverse.2.1 * shadowLightPosition.z
variable.float.lightvecZ    = gbufferModelViewInverse.0.2 * shadowLightPosition.x + gbufferModelViewInverse.1.2 * shadowLightPosition.y + gbufferModelViewInverse.2.2 * shadowLightPosition.z
uniform.vec3.lightvec       = vec3(lightvecX * lightvecNorm, lightvecY * lightvecNorm, lightvecZ * lightvecNorm)